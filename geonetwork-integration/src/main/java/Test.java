import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.authc.credential.DefaultPasswordService;
import org.apache.shiro.authc.credential.PasswordMatcher;
import org.apache.shiro.crypto.hash.*;
import org.apache.shiro.crypto.RandomNumberGenerator;
import org.apache.shiro.crypto.SecureRandomNumberGenerator;
import org.apache.shiro.util.ByteSource;
import org.geonetwork.shiro.GNPasswordService;
import org.springframework.security.crypto.password.StandardPasswordEncoder;

public class Test {
    private static String SECRET_SALT = "secret-hash-salt=";

    public static void main(String[] args) {
        testShiro();

        System.out.println("");
        System.out.println("-------------------");
        System.out.println("");

        testShiroGNPasswordService();

        System.out.println("");
        System.out.println("-------------------");
        System.out.println("");

        testSpringSecurity();
    }


    private static void testShiroGNPasswordService() {
        System.out.println("Shiro GNPasswordService:");
        System.out.println("");

        GNPasswordService gnPasswordService = new GNPasswordService();

        PasswordMatcher matcher = new PasswordMatcher();
        matcher.setPasswordService(gnPasswordService);

        // This is what would be stored in the database
        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo("admin",
                "46e44386069f7cf0d4f2a420b9a2383a612f316e2024b0fe84052b0b96c479a23e8a0be8b90fb8c2".toCharArray(),
                ByteSource.Util.bytes(SECRET_SALT), "jdbc");

        // Credentials to check
        UsernamePasswordToken tk = new UsernamePasswordToken();
        tk.setUsername("admin");
        tk.setPassword("admin".toCharArray());

        // Check if both match -- Should match
        boolean matches = matcher.doCredentialsMatch(tk, authenticationInfo);

        System.out.println("Shiro using GNPasswordService to compute hash: " + matches);

    }

    private static void testShiro() {
        System.out.println("Shiro:");
        System.out.println("");

        PasswordMatcher matcher = new PasswordMatcher();

        RandomNumberGenerator rng = new SecureRandomNumberGenerator();

        // Setup with SHA-256, 1000 iterations, private salt = SECRET_SALT
        DefaultHashService hashService = new DefaultHashService();
        hashService.setHashAlgorithmName("SHA-256");
        hashService.setPrivateSalt(ByteSource.Util.bytes(SECRET_SALT));
        hashService.setHashIterations(1000);
        hashService.setRandomNumberGenerator(rng);
        hashService.setGeneratePublicSalt(false);

        DefaultPasswordService defaultPasswordService = new DefaultPasswordService();
        defaultPasswordService.setHashService(hashService);

        matcher.setPasswordService(defaultPasswordService);

        // Credentials to check
        UsernamePasswordToken tk = new UsernamePasswordToken();
        tk.setUsername("admin");
        tk.setPassword("admin".toCharArray());

        HashRequest hashRequest = new HashRequest.Builder()
                .setAlgorithmName("SHA-256")
                .setIterations(1000)
                .setSource("admin")
                .build();

        // This is what would be stored in the database
        Hash hash = hashService.computeHash(hashRequest);

        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo();
        authenticationInfo.setCredentials(hash);

        // Check if both match -- Should match
        boolean matches = matcher.doCredentialsMatch(tk, authenticationInfo);

        System.out.println("Shiro using hashService to compute hash: " + matches + ", base64:" + hash.toBase64());


        // Check with a hashService not using the same private salt ...

        DefaultHashService hashServiceOtherPrivateSalt = new DefaultHashService();
        hashServiceOtherPrivateSalt.setHashAlgorithmName("SHA-256");
        hashService.setPrivateSalt(ByteSource.Util.bytes("OTHERSALT"));
        hashServiceOtherPrivateSalt.setHashIterations(1000);
        hashServiceOtherPrivateSalt.setRandomNumberGenerator(rng);
        hashServiceOtherPrivateSalt.setGeneratePublicSalt(false);

        hash = hashServiceOtherPrivateSalt.computeHash(hashRequest);

        authenticationInfo = new SimpleAuthenticationInfo();
        authenticationInfo.setCredentials(hash);

        // Check if both match -- Should not match
        matches = matcher.doCredentialsMatch(tk, authenticationInfo);

        System.out.println("Shiro using hashService with different salt used to compute hash: " + matches + ", base64:" + hash.toBase64());


        // This is what would be stored in the database, fixing the hash to a value generated by Spring Security
        authenticationInfo = new SimpleAuthenticationInfo();
        SimpleHash result = new SimpleHash("SHA-256");
        result.setBytes("46e44386069f7cf0d4f2a420b9a2383a612f316e2024b0fe84052b0b96c479a23e8a0be8b90fb8c2".getBytes());
        result.setIterations(1000);
        // Doesn't make any diff, but to use similar as done in DefaultHashService.computeHash
        result.setSalt(rng.nextBytes());
        authenticationInfo.setCredentials(result);

        // Check if both match
        matches = matcher.doCredentialsMatch(tk, authenticationInfo);
        System.out.println("Shiro using hash value from Spring security: " + matches + ", hash spring security: 46e44386069f7cf0d4f2a420b9a2383a612f316e2024b0fe84052b0b96c479a23e8a0be8b90fb8c2");
    }


    private static void testSpringSecurity() {

        System.out.println("Spring Security:");
        System.out.println("");

        // Use SHA-256, 1000 iterations, secret salt = SECRET_SALT
        StandardPasswordEncoder passwordEncoder = new StandardPasswordEncoder(SECRET_SALT);

        String springPasswordEncoderResult = "46e44386069f7cf0d4f2a420b9a2383a612f316e2024b0fe84052b0b96c479a23e8a0be8b90fb8c2";
        boolean matches = passwordEncoder.matches("admin", springPasswordEncoderResult);
        System.out.println("Using previous  passwordEncoder.encode, matches: " + matches + ",  passwordEncoder.encode: " + springPasswordEncoderResult);

        springPasswordEncoderResult = passwordEncoder.encode("admin");
        matches = passwordEncoder.matches("admin", springPasswordEncoderResult);
        System.out.println("New passwordEncoder.encode, " + matches + ",  passwordEncoder.encode: " + springPasswordEncoderResult);
    }

}
